#!/usr/bin/env python

# CS6244 Starter Learner 
# This is a very simple learner just to get you started. It is not a good submission.
# It implements some of the specifications listed and uses a simple ridge regressor 
# with odometry as input (you don't really have ground truth odometry in real-life)
# You are completely free to change the structure; I wrote this quickly so, it is
# very unlikely to be the best structure or be bug free. :P


import rospy
from geometry_msgs.msg import Twist, Pose 
from sensor_msgs.msg import LaserScan, Image
from nav_msgs.msg import Odometry
from std_msgs.msg import String, Bool
from cs6244.srv import Mode, ModeResponse


import numpy as np
from sklearn.datasets import load_linnerud
from sklearn.multioutput import MultiOutputRegressor
from sklearn.linear_model import Ridge
import json

import os

from model_il import ImitationNet
import model_il


# global data msgs
command = None 
laser = None 
pos = None 
image = None

# constants for the mode
IDLE = 0
COLLECT = 1
TRAIN = 2
EXECUTE = 3
CLEARDATA = 4

currmode = None

# constant for trajectory saving file name
num_traj = 0

# Topic Callbacks
def cmdCallback(vel):
	global command
	#rospy.loginfo(rospy.get_caller_id() + "command %s %s", vel.linear, vel.angular)
	command = vel 

	# your code comes here


def laserCallback(scan):
	global laser
	#rospy.loginfo(rospy.get_caller_id() + "scan %s", scan.ranges)
	laser = scan 
	# your code comes here


def odomCallback(odom):
	global pos
	#rospy.loginfo(rospy.get_caller_id() + "odom %s", odom.pose)
	pos = odom 
	# your code comes here


def cameraCallback(camera):
	global image
	#rospy.loginfo(rospy.get_caller_id() + "image %s", camera.encoding)
	image = camera
	# Do somemore preprocessing here, if any

def expertCallback(msg):
	global currmode
	print('Expert reached the goal. Resetting robot position')
	# Reset robot pose in gazebo and rviz
	rospy.sleep(1.0)
	pub_reset.publish(True)
	print('Changing mode back to idle.')
	rospy.sleep(0.1)
	pub_reset.publish(True)		# Reset again to make sure reset at the right pose
	currmode = IDLE


def handleModeChange(m):
	global currmode
	global pos
	global laser
	global image
	global command

	pub_expert = rospy.Publisher('learner_mode', String, queue_size=10)
	rospy.sleep(0.1)

	reqmode = int(m.reqmode)
	if reqmode == COLLECT:
		rospy.loginfo(rospy.get_caller_id() + ": COLLECT MODE")
		pub_expert.publish("supervised")
	elif reqmode == TRAIN:
		rospy.loginfo(rospy.get_caller_id() + ": TRAIN MODE")
	elif reqmode == EXECUTE:
		rospy.loginfo(rospy.get_caller_id() + ": EXECUTE MODE")
	elif reqmode == CLEARDATA:
		rospy.loginfo(rospy.get_caller_id() + ": CLEARDATA MODE")
	elif reqmode == IDLE:
		pos = laser = image = command = None 
		rospy.loginfo(rospy.get_caller_id() + ": IDLE MODE")
	else:
		reqmode = currmode 
		
	currmode = reqmode
	return ModeResponse(currmode)

def recordData2File(D):
	"""
	Process the latest trajectory data by removing all points that the turtlebot is not
	moving and dump the trajectory into a json file.

	Args:
		D {dict} -- the current trajectory data.
	"""
	global num_traj

	file_name = "./data/trajectory_" + str(num_traj) + '.json'

	# Process trajectory data. Remove all datapoints that are zero velocities
	i = 0
	while i < len(D["robot_vel"]):
		if D["robot_vel"][i] == [0.0, 0.0]:
			D["robot_pos"].pop(i)
			D["laser_scan"].pop(i)
			D["robot_vel"].pop(i)
		else:
			i += 1

	if len(D["robot_vel"]) > 0:
		with open(file_name, 'w') as fout:
			json.dump(D, fout)
		num_traj += 1


def collect(D):
	# data collection code 
	if (command is not None) and (pos is not None): 
		robot_pos = [pos.pose.pose.position.x, pos.pose.pose.position.y, 
						pos.pose.pose.position.z, 
					 	pos.pose.pose.orientation.x, pos.pose.pose.orientation.y, 
					 	pos.pose.pose.orientation.z, pos.pose.pose.orientation.w ] 
		robot_vel = [command.linear.x, command.angular.z]
		D["robot_pos"] += [ robot_pos ]
		D["laser_scan"] += [ laser.ranges ]
		D["robot_vel"] += [ robot_vel ]
		print("Stored", robot_pos, robot_vel)
	else:
		print(command)
		print(pos)

	return D


def train(model, dataset):
	global currmode

	# train neural network
	model_il.train(model)
	model.eval()

	print("Training round complete. Returning to Idle mode.")

	#done training, return to idle
	currmode=IDLE

def execute(model):
	global currmode

	vel_cmd = Twist()

	while abs(pos.pose.pose.position.x - 6.0) > 0.01 and \
			abs(pos.pose.pose.position.y + 1.0) > 0.01:
		# execute policy
		odom_input = np.array([[pos.pose.pose.position.x, pos.pose.pose.position.y,
								pos.pose.pose.orientation.z, pos.pose.pose.orientation.w]])
		vel = model_il.test(model, odom_input)
		vel_cmd.linear.x = vel[0][0]
		vel_cmd.angular.z = vel[0][1]
		pub_cmd.publish(vel_cmd)

	'''if (policy is None) or (cmdpub is None):
		return 
	X = [[pos.pose.pose.position.x, pos.pose.pose.position.y, pos.pose.pose.position.z, 
				 pos.pose.pose.orientation.x, pos.pose.pose.orientation.y, 
				 pos.pose.pose.orientation.z, pos.pose.pose.orientation.w ] ]

	y = policy.predict(X)

	# print
	print("Prediction: ", y)

	#publish msg
	twist = Twist()
	twist.linear.x = y[0][0]
	twist.linear.y = 0.0
	twist.linear.z = 0.0
	twist.angular.x = 0.0
	twist.angular.y = 0.0
	twist.angular.z = y[0][1]
	cmdpub.publish(twist)'''

	#done training, return to idle
	currmode=IDLE

def clearDataset(D):
	D = {'robot_pos': [], 'laser_scan': [], 'robot_vel':[]}
	return D


def learner():
	# add callbacks
	rospy.Subscriber("cmd_vel", Twist, cmdCallback)
	rospy.Subscriber("scan", LaserScan, laserCallback)
	rospy.Subscriber("odom", Odometry, odomCallback)
	rospy.Subscriber("/camera/rgb/image_raw", Image, cameraCallback)
	rospy.Subscriber("learner_feedback", Bool, expertCallback)

	# service handler
	modeservice = rospy.Service('mode_change', Mode, handleModeChange)
	
	rate = rospy.Rate(10) #Hz

	# dataset
	D = {'robot_pos': [], 'laser_scan': [], 'robot_vel':[]}

	# Initialize model (For now, its just odom as input)
	model = ImitationNet(control_dim=2, device='cpu')

	# main loop
	while not rospy.is_shutdown():
		if currmode == COLLECT:
			# code comes here
			D = collect(D)
		elif currmode == TRAIN:
			# code comes here
			train(model, D)
		elif currmode == EXECUTE:
			# code comes here
			execute(model)
		else:
			# write data to json file and reset D
			if len(D['robot_pos']) > 0:
				recordData2File(D)
			D = clearDataset(D)

		# any extra things to do per loop comes here 


		# sleep until we need
		rate.sleep()



if __name__=='__main__':
	rospy.init_node('learner', anonymous=True)
	# add ROS publishers
	pub_reset = rospy.Publisher("reset_robot_pos", Bool, queue_size=10)
	pub_cmd = rospy.Publisher("/cmd_vel", Twist, queue_size=10)
	learner()
