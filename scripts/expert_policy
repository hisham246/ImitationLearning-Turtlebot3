#!/usr/bin/env python

# This script contains a service that listens to learner/daglearner script 
# and executes the expert policy upon receiving the signal from the 
# learner/daglearner script. The expert policy executes the entire trajectory
# if called by learner, while just one step if called by daglearner.

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from std_msgs.msg import String, Bool



class Expert:
	def __init__(self):
		rospy.init_node('expert_policy')

		# Initialize move_base SimpleActionClient and related variables
		self.client = actionlib.SimpleActionClient('move_base',MoveBaseAction)
		self.client.wait_for_server()
		self.goal = MoveBaseGoal()
		self.goal.target_pose.header.frame_id = "map"
		self.goal.target_pose.header.stamp = rospy.Time.now()
		self.goal.target_pose.pose.position.x = 6.0
		self.goal.target_pose.pose.position.y = -1.0
		self.goal.target_pose.pose.orientation.z = 0.7071
		self.goal.target_pose.pose.orientation.w = -0.7071

		# Initialize misc variables
		self.mode = ''

		# Initialize ROS publishers and subscribers
		self.pub_mode = rospy.Publisher("learner_feedback", Bool, queue_size=10)
		self.sub_mode = rospy.Subscriber(
									"learner_mode", String, self.learnerModeCallback)
		self.sub_stop = rospy.Subscriber("stop", Bool, self.stopCmdCallback)
		print('done')

	def learnerModeCallback(self, msg):
		# Check whether dagger or supervised
		if msg.data == 'dagger':
			self.mode = 'dagger'
			print('Executing just one step')
			self.moveToGoal()
			self.pub_mode.publish(True)
		elif msg.data == 'supervised':
			self.mode = 'supervised'
			print('Executing the entire trajectory')
			self.moveToGoal()
			self.pub_mode.publish(True)
		else:
			print('Wrong input. Feedback to learner')
			self.pub_mode.publish(False)

	def stopCmdCallback(self, msg):
		stop_cmd = MoveBaseGoal()
		stop_cmd.target_pose.header.frame_id = "map"
		stop_cmd.target_pose.header.stamp = rospy.Time.now()
		stop_cmd.target_pose.pose.position.x = -6.503
		stop_cmd.target_pose.pose.position.y = -2.422
		stop_cmd.target_pose.pose.orientation.z = -0.77
		stop_cmd.target_pose.pose.orientation.w = -0.63
		self.client.send_goal(stop_cmd)

	def moveToGoal(self):
		# Send goal (cancel thereafter if dagger)
		self.client.send_goal(self.goal)

		if self.mode == 'dagger':
			rospy.sleep(2.0)
			self.client.cancel_goal()

		wait = self.client.wait_for_result()
		if not wait:
			rospy.logerr("Action server not available!")
			rospy.signal_shutdown("Action server not available!")


if __name__ == '__main__':
	expert = Expert()
	rospy.spin()