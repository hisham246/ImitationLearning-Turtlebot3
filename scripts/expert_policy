#!/usr/bin/env python

# This script listens to learner/daglearner script and executes the expert 
# policy upon receiving the signal from the learner/daglearner script. 
# The expert policy executes the entire trajectory if called by learner, 
# while just one step if called by daglearner.

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from std_msgs.msg import String, Bool
from geometry_msgs.msg import Twist



class Expert:
	def __init__(self):
		rospy.init_node('expert_policy')

		# Initialize move_base SimpleActionClient and related variables
		self.client = actionlib.SimpleActionClient('move_base',MoveBaseAction)
		self.client.wait_for_server()
		self.goal = MoveBaseGoal()
		self.goal.target_pose.header.frame_id = "map"
		self.goal.target_pose.header.stamp = rospy.Time.now()
		self.goal.target_pose.pose.position.x = 6.0
		self.goal.target_pose.pose.position.y = -1.0
		self.goal.target_pose.pose.orientation.z = 0.7071
		self.goal.target_pose.pose.orientation.w = -0.7071

		# Initialize misc variables
		self.mode = ''
		self.initial_cmd = Twist()
		self.initial_cmd.linear.x = 0.22
		self.initial_cmd.angular.z = -0.09

		# Initialize ROS publishers and subscribers
		self.pub_feedback = rospy.Publisher("learner_feedback", String, queue_size=10)
		self.pub_cmd = rospy.Publisher("cmd_vel", Twist, queue_size=10)
		self.sub_mode = rospy.Subscriber(
							"learner_mode", String, self.learnerModeCallback)

	def learnerModeCallback(self, msg):
		# Check whether dagger or supervised
		if msg.data == 'dagger':
			self.mode = 'dagger'
			print('Executing just one step')
			self.moveToGoal()
		elif msg.data == 'supervised':
			self.mode = 'supervised'
			print('Executing the entire trajectory')
			for i in range(4):
				self.pub_cmd.publish(self.initial_cmd)
			self.moveToGoal()
			self.pub_feedback.publish('reset')
		else:
			print('Wrong input. Feedback to learner')
			self.pub_feedback.publish('reset')

	def moveToGoal(self):
		# Send goal (cancel thereafter if dagger)
		self.client.send_goal(self.goal)

		if self.mode == 'supervised':
			wait = self.client.wait_for_result()
			if not wait:
				rospy.logerr("Action server not available!")
				rospy.signal_shutdown("Action server not available!")


if __name__ == '__main__':
	expert = Expert()
	rospy.spin()